#!/usr/bin/env bash

set -eu
set -o pipefail
#set -x

trap cleanup EXIT

# auxiliary variables
deps=("convert" "ocrmypdf" "pdftoppm")
tempdir_suffix=".contrastize"
scanned_document_name="scanned-document.pdf"
tempdir_name=""
page_ranged_input_file=""

# command line arguments
input_file=""
output_file=""
force_output=0
density="300"
verbose=0
keep_temp=0
first_page=""
last_page=""

cleanup() {
	local original_retval="$?"
	[ "$keep_temp" -eq 1 ] && return $original_retval
	[ -n "$tempdir_name" ] && rm -rf "$tempdir_name"
	return $original_retval
}

# creates tempdir and sets $tempdir_name variable. This variable will be used by the
# `cleanup` function to remove all the temp files at the end of execution
create_tempdir() {
	tempdir_name=$(mktemp -d --suffix="$tempdir_suffix")
	[ $? -eq 0 ] || error "Error creating temp directory"
}

# generates an empty channel file with the same dimensions as the input file. This way, we
# reuse empty channel files for pages with the same size in a given document
get_black_channel_file_for_page() {
	local channel_k_file="$1"
	local dimensions=$(identify -format "%w_%h" "$channel_k_file")
	local page_empty_channel_file="${tempdir_name}/empty_${dimensions}.png"
	if [ ! -e "$page_empty_channel_file" ]; then
		convert "$channel_k_file" -density "$density" \
			-evaluate set 0% -negate "$page_empty_channel_file"
	fi
	echo "$page_empty_channel_file"
}

create_cmy_pages() {
	local cyan="empty_channel_file"
	local yellow="empty_channel_file"
	local magenta="empty_channel_file"
	if [ "$color_to_use" == "cyan" ]; then
		cyan="black_channel"
	fi;
	if [ "$color_to_use" == "magenta" ]; then
		magenta="black_channel"
	fi;
	if [ "$color_to_use" == "red" ]; then
		magenta="black_channel"
		yellow="black_channel"
	fi;
	if [ "$color_to_use" == "green" ]; then
		cyan="black_channel"
		yellow="black_channel"
	fi;
	for black_channel in ${tempdir_name}/channel_k*.tiff; do
		local empty_channel_file=$(get_black_channel_file_for_page "$black_channel")
		local processed_page_file=${black_channel/channel_k/cmy}
		processed_page_file="${processed_page_file%.tiff}.png"
		convert "${!cyan}" \
			"${!magenta}" \
			"${!yellow}" \
			"$empty_channel_file" \
			-combine -colorspace CMYK "$processed_page_file"
	done;
}

# concat pages generated by `create_cmy_pages` into a new PDF document and place it in the
# working directory, alongside with the input document
concat_processed_pages() {
	local image_layer_output="$tempdir_name"/image-layer.output.pdf
	img2pdf `ls -1 "$tempdir_name"/cmy*.png | sort -V` \
		-o "$image_layer_output"
	pdftk "$page_ranged_input_file" multistamp "$image_layer_output" \
		output "$output_file"
}

display_success_message() {
	echo "display_success_message"
}

# display error message and die
error() {
	 >&2 echo "error: $1"
	exit 1
}

verbose() {
	[ "$verbose" -eq 1 ] && echo "$1"
}

# make sure dependencies are installed
validate_deps() {
	for dep in "${deps[@]}"; do
		set +e
		which "$dep" > /dev/null
		[ "$?" -ne 0 ] && error "dependency $dep was not found"
		set -e
	done;
}

print_usage() {
    cat <<'EOF'
Usage: contrastize -i <filename> -o <filename> [OPTIONS]

Mandatory options:
  -i, --input <filename>
      Input file to be processed. Must be a valid filename.

  -o, --output <filename>
      Output file to generate. Must be a valid filename.

Optional options:
  -h, --help
      Show this help message and exit.

  -d, --density
      Sets document's density (resolution), in DPI. Default is 300

  -v, --verbose
      Enable verbose mode. Prints extra details during execution.

  -f, --force
      Overwrite the output file if it already exists.

  -k, --keep-temp
      Keep temporary files instead of deleting them after execution.

Examples:
  contrastize -i source.txt -o result.txt
  contrastize --input data.md --output out.html --verbose
  contrastize -f -i in.md -o out.md -c red
EOF
}

# function `get_suffixed_filename`
# Arguments:
# $1: input file path
# $2: file name suffix
# $3 (optional): new extension
#
# Example:
# $1: /home/fool/input.pdf
# $2: "barl"
# Result: /home/fool/input.barl.pdf
get_suffixed_filename() {
	[ -z "$1" ] && error "get_suffixed_filename: no file name"
	[ -z "$2" ] && error "get_suffixed_filename: no suffix"
	local basename=$(basename "$1")
	local filename_noext="${basename%.*}"
	local dirname=$(dirname "$1")
	local extension="${basename##*.}"
	if [ -n "$3" ]; then
		extension="$3"
	fi;
	echo "${dirname}/${filename_noext}.""$2"".${extension}"
}

# create a temporary copy of the input file, limiting the range of its pages if necessary.
# This copy is necessary because the last step of the pipeline (a pdftk multistamp
# operation) doesn't allow us to select a page range -- therefore we must give it a
# pdf with the right number of pages for it to operate upon
create_page_ranged_input() {
	page_ranged_input_file="${tempdir_name}/page_ranged_input.pdf"
	local cat_first_page="1"
	local cat_last_page="end"
	if [ -n "$first_page" ]; then
		cat_first_page=${first_page}
	fi
	if [ -n "$last_page" ]; then
		cat_last_page=${last_page}
	fi
	if [[ -n "$first_page" || -n "$last_page" ]]; then
		pdftk "$input_file" cat ${cat_first_page}-${cat_last_page} \
			output "$page_ranged_input_file"
	else
		cp "$input_file" "$page_ranged_input_file"
	fi
}

# create a grayscale version and save it in the tempdir
create_picture_pages() {
	pdftoppm -r "$density" -png "$page_ranged_input_file" \
		"${tempdir_name}/"input
}

create_scanned_pages() {
	for input_page in ${tempdir_name}/input-*.png; do
		convert "$input_page" -colorspace Gray -level 50%,70% -sharpen 0x1 \
			-despeckle "${input_page/input/scanned}.png"
	done;
	img2pdf `ls -1 $tempdir_name/*scanned*.png | sort -V` \
		-o "${tempdir_name}/${scanned_document_name}"
}

parse_args() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-h|--help)
				print_usage
				exit 0
				;;
			-v|--verbose)
				verbose=1
				shift
				;;
			-f|--force)
				force_output=1
				shift
				;;
			-k|--keep-temp)
				keep_temp=1
				shift
				;;
			-d|--density)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a density value"
				fi
				density="$2"
				shift 2
				;;
			--first)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a page number"
				fi
				first_page="$2"
				shift 2
				;;
			--last)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a page number"
				fi
				last_page="$2"
				shift 2
				;;
			-i|--input)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a filename"
				fi
				input_file="$2"
				shift 2
				;;
			-o|--output)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a filename"
				fi
				output_file="$2"
				shift 2
				;;
			*)
				error "Unknown parameter $1"
				exit 1
				;;
		esac
	done

	[ -z "$input_file" ] && error "input file not defined via option -i"
	[ -f "$input_file" ] || error "input file $input_file doesn't exist or isn't a regular file"
	[ -z "$output_file" ] && error "output file not defined via option -o"
	[ "$input_file" == "$output_file" ] && error "using the same file as both input and output is not recomended"
	[[ -f "$output_file" && "$force_output" -ne 1 ]] && error "output file $output_file already exists and --force is not specified"
	return 0
}

apply_ocr_and_create_output() {
	ocrmypdf --clean --image-dpi 300 --output-type pdfa --force-ocr \
		${tempdir_name}/${scanned_document_name} ${output_file}
}

main() {
	parse_args "$@"
	validate_deps
	create_tempdir
	create_page_ranged_input
	create_picture_pages
	create_scanned_pages
	apply_ocr_and_create_output
}

main "$@"
